// Generated by CoffeeScript 1.4.0
var OWNER_REGEX, app, derby, get, md5, post, randomColor, randomShift, ready, renderPaths, renderSlime, view, _ref;

md5 = require('MD5');

derby = require('derby');

_ref = app = derby.createApp(module), get = _ref.get, post = _ref.post, view = _ref.view, ready = _ref.ready;

derby.use(require('../../ui'));

OWNER_REGEX = /([\w ]+)#?(.+)?/;

get('/', function(page) {
  return page.redirect('/i');
});

get('/:space*', function(page, model, params, next) {
  model.setNull('_ink_remaining', 0);
  return next();
});

get('/:space', function(page, model, _arg) {
  var space;
  space = _arg.space;
  return model.subscribe("" + space + ".inks", function(err, inks) {
    model.ref('_inks', inks.filter().where('id').exists());
    model.setNull('_inks', []);
    model.fn('_inks_sorted', '_inks', function(inks) {
      return inks.slice().reverse();
    });
    return page.render('index', {
      space: space
    });
  });
});

get('/:space/new', function(page, model, _arg) {
  var space;
  space = _arg.space;
  model.set('_paths', []);
  model.set('_submit_ready', false);
  return page.render('new', {
    space: space
  });
});

post('/:space/new', function(page, model, _arg) {
  var data_url, id, space, _ref1;
  space = _arg.space, (_ref1 = _arg.body, data_url = _ref1.data_url);
  id = model.id();
  model.set(("" + space + ".inks.") + id, {
    data_url: data_url,
    id: id
  });
  return page.redirect("/" + space);
});

get('/:space/:inkid', function(page, model, _arg) {
  var inkid, space;
  space = _arg.space, inkid = _arg.inkid;
  model.set('_is_valid', false);
  return model.subscribe("" + space + ".inks." + inkid, function(err, ink) {
    model.ref('_ink', ink);
    return page.render('ink');
  });
});

post('/:space/:inkid', function(page, model, _arg) {
  var hash, inkid, name, owner, owner_parts, space, _ref1;
  space = _arg.space, inkid = _arg.inkid, (_ref1 = _arg.body, owner = _ref1.owner, name = _ref1.name);
  if (!owner || !name) {
    return;
  }
  owner_parts = owner.match(OWNER_REGEX);
  if (!owner_parts[1]) {
    return;
  }
  if (owner_parts[2]) {
    hash = md5(owner_parts[2]);
  } else {
    hash = '';
  }
  model.ref('_ink', "" + space + ".inks." + inkid);
  model.set('_ink.owner', owner_parts[1]);
  model.set('_ink.owner_hash', hash);
  model.set('_ink.name', name);
  model.incr('_ink_remaining', 25);
  return page.redirect("/" + space);
});

renderPaths = function(segments) {
  var p, path, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = segments.length; _i < _len; _i++) {
    path = segments[_i];
    p = new paper.Path(path);
    _results.push(p.style = {
      strokeColor: 'black',
      strokeWidth: 8
    });
  }
  return _results;
};

randomShift = function(point, amt) {
  return new paper.Point(point.x + (Math.random() - 0.5) * amt, point.y + (Math.random() - 0.5) * amt);
};

randomColor = function(h, s, b) {
  if (h == null) {
    h = Math.random() * 360;
  }
  if (s == null) {
    s = 0.6;
  }
  if (b == null) {
    b = 1;
  }
  return new paper.HsbColor(h, s, b);
};

renderSlime = function(size) {
  var eye, p, segment, _i, _len, _ref1;
  global.slime = p = new paper.Path.Circle(paper.view.center, size);
  p.position.y += size * 0.25;
  p.style = {
    strokeColor: 'black',
    strokeWidth: size / 9.1,
    fillColor: randomColor()
  };
  console.log(p.segments);
  p.flatten(size);
  _ref1 = p.segments;
  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
    segment = _ref1[_i];
    segment.point = randomShift(segment.point, size * 0.90);
  }
  p.smooth();
  eye = new paper.Path.Oval(new paper.Rectangle(randomShift(paper.view.center, size * 0.5), new paper.Size(size / 12.1, size / 6.1)));
  eye.position.x += size * 0.1;
  eye.fillColor = 'black';
  eye.segments[1].point = randomShift(eye.segments[1].point, size / 24.1);
  eye.segments[3].point = randomShift(eye.segments[3].point, size / 30.1);
  global.eye2 = eye.clone();
  eye2.position.x -= size * 0.5 * Math.random() + (size / 9.1);
  return eye2.scale(-1, 1);
};

ready(function(model) {
  this.validateAdoption = function(e) {
    var name, owner, owner_parts;
    owner = document.getElementById('adopt_owner').value;
    name = document.getElementById('adopt_name').value;
    if (!owner || !name) {
      return;
    }
    owner_parts = owner.match(OWNER_REGEX);
    if (!owner_parts[1]) {
      return;
    }
    return model.set('_is_valid', true);
  };
  this.newColor = function() {
    return slime.fillColor = randomColor();
  };
  this.inkPlz = function() {
    return model.incr('_ink_remaining', 20);
  };
  this.initCanvas = function() {
    var path, tool;
    console.log('init');
    model.setNull('_paths', []);
    path = null;
    paper.setup('theCanvas');
    view = paper.view;
    view.draw();
    renderSlime(100);
    view.onFrame = function() {
      return path != null ? path.smooth() : void 0;
    };
    tool = new paper.Tool();
    tool.onMouseDown = function(e) {
      if (model.get('_ink_remaining') <= 0) {
        return;
      }
      path = new paper.Path();
      path.style = {
        strokeColor: 'black',
        strokeWidth: 6
      };
      path.add(e.point);
      path.add(e.point);
      return model.incr('_ink_remaining', -1);
    };
    tool.onMouseDrag = function(e) {
      if (model.get('_ink_remaining') <= 0) {
        return;
      }
      path.lastSegment.point = e.point;
      if (path.segments[path.segments.length - 2].point.getDistance(e.point) > 10) {
        path.add(e.point);
        return model.incr('_ink_remaining', -1);
      }
    };
    return tool.onMouseUp = function(e) {
      var raster;
      if (model.get('_ink_remaining') <= 0) {
        return;
      }
      model.set('_submit_ready', false);
      raster = paper.project.activeLayer.rasterize();
      model.set('_data_url', raster.image.toDataURL());
      model.set('_submit_ready', true);
      return raster.remove();
    };
  };
  return app.on("render:new", function(e) {
    console.log(e);
    return app.initCanvas();
  });
});

view.fn('json', function(obj) {
  return JSON.stringify(obj);
});

view.fn('debug', function(obj) {
  console.log(obj);
  return obj;
});
